#!/usr/bin/env node

const transliteration = require("transliteration");
const fs = require("fs");
const path = require("path");
const commandLineArgs = require("command-line-args");
const commandLineUsage = require("command-line-usage");

const optionDefinitions = [
  {name: "dir", alias: "d", type: String, description: "Relative directory path with images"},
  {name: "out", alias: "o", type: String, description: "Output file path"},
  {name: "read", alias: "r", type: String, description: "Read directory path (optional)"},
  {
    name: "ts",
    alias: "t",
    type: Boolean,
    description: "Should the output file be generated as a TypeScript file (optional)",
  },
];

const cmdOptions = commandLineArgs(optionDefinitions);
const cmdUsage = commandLineUsage([{header: "Options", optionList: optionDefinitions}]);

const entriesRegex = new RegExp("^((?!@).)*$");

run()
  .then(() => console.log("Done"))
  .catch((error) => console.error(`Error happened while generating resources:\n${error}`));

/**
 * @param {string} dir
 * @param {string} out
 * @param {string} fileName
 * @returns {FileEntry}
 */
function assembleFileEntry(dir, out, fileName) {
  return {
    relativeResourcePath: path.relative(path.dirname(out), path.join(dir, fileName)).replace(/\\/g, "/"),
    variableName: fileName
        .toLowerCase()
        .replace(/(.*)(.(png|jpg|jpeg|gif|bmp|svg))$/, "$1")
        .replace(/^\d+/, ($0) => new Array($0.length + 1).join("_"))
        .replace(/\W+/g, "_"),
  };
}

async function run() {
  checkOptions(cmdOptions);
  console.log(`Started searching resources in ${cmdOptions.dir}`);

  const resources = [];

  let content =
    `/* eslint-disable */` +
    `\n/* tslint:disable */` +
    `${cmdOptions.ts ? '\nimport {ImageURISource} from "react-native";' : ""}` +
    `\n\n/**` +
    `\n * This file is auto-generated by react-native-image-resource-generator` +
    `\n * !!! DO NOT EDIT !!!` +
    `\n * For more information check the documentation:` +
    `\n * https://github.com/svbutko/react-native-image-resource-generator` +
    `\n*/`;

  await prepareFiles(cmdOptions.dir);
  await collectEntries(cmdOptions.dir, path.join("root", path.dirname(cmdOptions.out), cmdOptions.read || ""), true, resources);

  for (const resourceEntry of resources) {
    content += generateClassExport(resourceEntry.name, resourceEntry.entries);
  }

  fs.writeFileSync(cmdOptions.out, content);
}

/**
 * @param {string} dir
 * @param {string} out
 * @param {boolean} isRoot
 * @param {ResultEntries[]} result
 * @returns {Promise<void>}
 */
async function collectEntries(dir, out, isRoot, result) {
  const files = await readDir(dir);

  /** @type {ResultEntries} */
  const item = {
    name: isRoot ? "ImageResources" : toCamelCase(dir.split(path.sep).pop()) + "Resources",
    entries: [],
  };

  for (const file of files) {
    const joinedPath = path.join(dir, file);

    if (fs.lstatSync(joinedPath).isDirectory()) {
      await collectEntries(joinedPath, out, false, result);
    } else if (entriesRegex.exec(file)) {
      item.entries.push(assembleFileEntry(dir, out, file));
    }
  }

  result.push(item);
}

/**
 * @param {string} className
 * @param {FileEntry[]} entries
 * @returns {string}
 */
function generateClassExport(className, entries) {
  return `\n\nexport class ${className} {\n${entries.map((entry) => getEntryDeclaration(entry)).join("\n")}\n}`;
}

/**
 * @param {FileEntry} entry
 * @returns {string}
 */
function getEntryDeclaration(entry) {
  if (cmdOptions.ts) {
    return `  static readonly ${entry.variableName}: ImageURISource = require("${entry.relativeResourcePath}");`;
  }

  return `  static ${entry.variableName} = require("${entry.relativeResourcePath}");`;
}

/**
 * @param {string} dir
 * @returns {Promise<string[]>}
 */
function readDir(dir) {
  return new Promise((resolve, reject) => {
    fs.readdir(dir, (err, files) => {
      if (err) {
        reject(err);
      }
      resolve(files);
    });
  });
}

/**
 * @param {string} str
 * @returns {string}
 */
function toCamelCase(str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}

/**
 * @param {Options} options
 * @returns {void}
 */
function checkOptions(options) {
  if (options.dir == null || options.out == null) {
    throw new Error(`Missing non-optional options.\nList of options:\n ${cmdUsage}`);
  }
}

/** @type {OptionsTransliterate} */
const transliterationOptions = {
  trim: true,
};

/**
 * @param {string} dir
 * @returns {void}
 */
async function prepareFiles(dir) {
  const files = await readDir(dir);

  for (const file of files) {
    const joinedPath = path.join(dir, file);

    if (fs.lstatSync(joinedPath).isDirectory()) {
      await prepareFiles(joinedPath);
    } else {
      const escapedFile = transliteration.transliterate(file, transliterationOptions)
        .replace(/[,]/g, ".")
        .replace(/[^A-Za-z0-9_@.]/g, "_");

      if (escapedFile !== file) {
        fs.renameSync(joinedPath, path.join(dir, escapedFile));
      }
    }
  }
}

/**
 * @typedef Options
 * @prop {string} dir
 * @prop {string} out
 * @prop {string} read
 * @prop {string} ts
 */

/**
 * @typedef FileEntry
 * @prop {string} relativeResourcePath
 * @prop {string} variableName
 */

/**
 * @typedef ResultEntries
 * @prop {string} name
 * @prop {FileEntry[]} entries
 */

/**
 * @typedef {import('transliteration/dist/node/src/types').OptionsTransliterate} OptionsTransliterate
 */
